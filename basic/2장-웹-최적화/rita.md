# 2장 웹 최적화

웹사이트에 검색 엔진 최적화(Search Engine Optimization, SEO)를 실행한다.

SEO가 적용된 웹 사이트는 다른 사이트에 비해 상단 노출 회수가 높다 -> 많은 방문자를 이끌어낸다.

## 2.1 웹 최적화란

최고의 성능을 만드는 최적화 조건을 갖추는 것. 세가지가 있다.

### 2.1.1 프런트엔드 최적화

- 웹 UI/UX와 관련된 최적화

  HTML, JavaScrip, CSS, Image fil, 타사 파일 자체의 모음들이 콘텐츠를 만들어낼 때 최적화를 진행함.

  FE 최적화가 잘 된 사이트는 브라우저에서 콘텐츠를 다운로드, 로딩, 렌더링할 때 속도가 빠르다.

- FE 최적화 기술은 사용자 환경에 따라 달라진다.

  사용자의 기기, 네트워크 속도와 품질, 브라우저 등 상대적임.

  따라서 어떤 경우에 성능이 저하되는지 파악하고 조치를 취해야함.

- FE 최적화 기술의 예

  - 스크립트를 병합(merge)하여 브라우저의 호출 개수를 줄임
  - 스크립트 크기를 최소화해 바이트(byte) 자체를 줄임
  - 스크립트를 gzip 등으로 압축하여 전달
  - WebP 등으로 브라우저 이미지 형식을 최적화

  - 이미지 손실, 무손실 압축
  - Cache-Control 응답 헤더를 통해 브라우저 캐시를 충실히 사용
  - 도메인 수를 줄여 DNS 조회를 최소화
  - DNS 정보 미리 읽어 오기
  - CSS를 HTML 상단에, 자바스크립트를 HTML의 하단에 위치시키기
  - 페이지 미리 읽어 오기(page prefetching)
  - 타사 스크립트가 웹 성능을 방해하지 않도록 조정

### 2.1.2 백엔드 최적화

- 웹 UI를 로직에 맞게 만듬
- 백엔드 : 웹 서버, 웹 애플리케이션 서버, 데이터베이스, 로드 밸런싱, DNS 서버 등
- BE 최적화의 목표 : 이 시스템들을 튜닝해 정상 출력을 만드는 것
- BE 최적화는 FE에 비해 가시적 효과가 크지 않지만 웹사이트의 빠른 로딩보다 네트워크를 정상적으로 사용하고 콘텐츠를 전달하기 위해 반드시 필요한 요소
- BE 최적화의 예
  - DNS 응답이 빨라지도록 서버 증설
  - DNS 응답을 빠르게 할 수 있도록 DNS 정보를 최대한 캐싱
  - 웹 서버가 있는 데이터 센터의 네트워크 출력(throughput)/대역폭(bandwidth) 증설
  - 웹 서버, 웹 애플리케이션 서버의 CPU/RAM 증설
  - 프록시 서버를 설정하여 웹 콘텐츠를 캐싱
  - CDN(Content Delivery Network)을 사용해 인터넷상에 콘텐츠 캐싱
  - 데이터베이스 정규화로 디스크 I/O 최적화
  - 데이터베이스 캐싱으로 응답을 빠르게
  - 로드 밸런싱을 통해 가장 성능이 좋은 웹 서버로 요청을 연결
  - 웹 애플리케이션 로직을 가볍고 빠르게 개발

### 2.1.3 프로토콜 최적화

웹 콘텐츠를 전달하는 HTTP/HTTPS 프로토콜 자체의 효과를 극대화하면 웹 서버가 클라이언트에게 콘텐츠를 최대 속도와 최저 지연 시간으로 전달할 수 있다. 

프로토콜 최적화 : 웹 콘텐츠를 더 빠르게 요청하고 응답하도록 프로토콜을 업그레이드하는 과정이다.

## 2.2 TCP/IP 프로토콜

웹은 TCP/IP 프로토콜의 일종인 HTTP를 사용해 콘텐츠를 전달한다. 

- **TCP/IP 프로토콜** : OSI 7계층 중 4번째 전송계층에 속함

  전송 계층 : 네트워크상에서 송신자와 수신자 사이에 데이터 전송을 보장하는 역할

- **HTTP** : 7번째 응용계층에 속함

  응용 계층 : 메일, FTP, 인터넷 등 실제 네트워크상에서 SW와 사용자의 상호 연동을 담당함

- 전송과 응용 계층은 독립적인 것이 아니라 상위 계층인 응용 계층이 하위 계층인 전송 계층을 바탕으로 운용되는 구조

- TCP 네트워크를 사용하는 네트워크에 있어 대표적인 성능 지표 : 대역폭, 지연 시간

  - **대역폭** : 특정 시간동안 얼마나 많은 네트워크 트래픽을 보낼 수 있는지. 시간당 전송량

    예) 크기가 큰 이미지 파일을 다운로드하려면 완료시간은 클라이언트와 서버 사이 대역폭에 영향을 받음

  - 지연 시간 : 클라이언트와 서버간 콘텐츠를 전달하는 물리적인 시간

    클라이언트와 서버  사이 요청, 전달, 응답까지 걸리는 시간.

    예) 브라우저가 콘텐츠를 해석하고 화면에 렌더링하는 단계는 클라이언트 측에서만 실행되므로 지연 시간에 포함되지 않음. 

  - RTT(Round Trip Time) : 서버와 클라이언트 두 호스트를 모두 왕복하는 데 걸리는 지연 시간

    게임, 화상 채팅 등의 품질에 영향을 줌.

    예) 스트리밍 서비스 회사는 지연시간이 길고 짧음에 따라 전달받는 영상 파일의 품질을 조절하여 버퍼링을 줄일 수 있는 가변 스트리밍 방식(adaptive streaming)을 사용함

### 2.2.1 TCP 혼잡 제어

성능 저하 요소를 해결하는 TCP의 기술을 알아보자.

#### 문제

- **TCP 혼잡제어**(congestion control)는 TCP 네트워크의 통신량을 조절하여 TCP 네트워크가 혼잡해지지 않도록 하는 방식

- **TCP 혼잡 붕괴**(congestion collapse)는 TCP 네트워크의 통신량이 실제 처리량보다 많아서 문제가 발생하는 것

  인터넷에 연결된 호스트들이 최대한 많은 정보를 전송하려고 많은 네트워크 패킷을 보내기 때문에 발생함

#### 해결

- **TCP 혼잡 제어 기술**

  패킷을 보내는 쪽에서 네트워크에서 수용할 수 있는 양을 파악, 그만큼의 패킷만 보내는 약속으로 해결

  받는 쪽은 패킷이 정상적으로 송신되었음을 알리는 ACK 패킷을 보냄

  ACK 패킷을 받은 호스트는 지속적으로 패킷을 보낼 수 있음

  처음부터 네트워크가 얼만큼의 패킷을 수용할 수 있는지 정확히 파악하는 것은 어렵고, 그 값도 시간에 따라 변함. 따라서 호스트가 네트워크의 상태를 파악하고 전송 속도를 조절하는 것 또한 혼잡 제어 기능 중 하나.

- 혼잡 제어의 대표 기술

  - **느린 시작**(slow start) : TCP 연결이 시작되면 전송 가능한 버퍼의 양인 혼잡 윈도우(Congestion Window, CWND)의 초기값을 작게 설정하여 전송. 패킷이 정상도착할 때마다 더 많은 패킷을 보냄. 패킷 유실이 발생하기 전까지 반복. 

    즉, 초기에 적은 패킷을 보내면서 곱셈 방식으로 전송 패킷의 크기를 빠르게 늘림

  - **빠른 재전송**(fast retransmit) : 먼저 도착해야하는 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 수신자가 일단 ACK패킷을 보냄

  - **흐름 제어**(flow control) : TCP 송신자가 데이터를 너무 빠르게 혹은 너무 많이 전송하여 수신자의 버퍼가 오버플로되는 현상을 방지

## 2.3 HTTP 프로토콜

HyperText Transfer Protocol

텍스트 이상 콘텐츠들을 웹에서 전달하기 위해 만들어진 프로토콜.

웹은 HTTP 프로토콜을 통해 전달되므로 HTTP 성능을 개선하면 웹 성능도 향상된다.

### 2.3.1 HTTP 최적화 기술

~ HTTP/0.9 버전까지는 클라이언트와 서버의 인터넷 통신 정상화, 가용성, 신뢰성 등에 초점을 두었음

HTTP/1.0버전부터는 클라이언트와 서버 사이 요청과 응답을 빠르게 할 수 있는 연구가 진행됨.

웹이 멀티호스트 환경으로 변하면서, HTTP/1.1버전부터 **멀티호스팅 기능**과 클라이언트와 서버 사이에서 TCP/IP 연결을 재사용하는 기능을 추가하였다. **연결 재사용, 파이프라이닝 기법** 등.

### 2.3.2 HTTP 지속적 연결

- 초기 버전 : 통신을 통해 여러 오브젝트를 요청하고 응답하려면 3-way handshake 방식으로 TCP연결을 함

  3-way handshake 방식 : 클라이언트와 서버 사이 SYN, SYN-ACK, ACK의 3번의 요청과 응답으로 이루어짐

  장점 : 송신자와 수신자 사이 신뢰성, 안전한 통신을 추구하는 TCP 알고리즘

  문제점 : 동시에 많은 웹 콘텐츠를 전달해야하는 HTTP 통신에서 번거로움이 발생

- 지속적 연결 기술의 등장

  클라이언트와 서버가 TCP상에서 한 번 연결되면 둘 사이의 연결이 완전히 끊어지기 전까지 맺어진 연결을 지속적으로 재사용하는 기술

  HTTP request header에 Connection 헤더, keep-alive 속성으로 지속적인 연결을 요청

  HTTP/1.0 RFC의 규약이 됨

  HTTP/1.1 버전에서는 Connection 헤더를 사용하지 않아도 모든 요청과 응답이 HTTP 지속적 연결을 기본으로 지원함. HTTP 응답이 완료되거나 TCP 연결을 끊어야할 때만 Connection 헤더를 사용함.

- 멀티플렉싱 기술의 등장

  HTTP/2 버전은 단일 TCP 연결을 통해 클라이언트와 서버 사이 응답 지연없이 스트림형태로 다수의 HTTP 요청과 응답을 주고받을 수 있음

### 2.3.3 HTTP 파이프라이닝

- 배경 : HTTP 선입 선출의 단점을 극복하자

  HTTP 요청과 응답이 여럿일때, 하나의 응답이 지연되면 나머지 요청과 응답 모두 지연되었음.

- HTTP 파이프라이닝 : 먼저 보낸 요청의 응답이 없어도 다음 요청을 병렬적으로 수신자 측에 전송하는 기술

  중간에 응답 지연이 발생하더라도 클라이언트는 먼저 서버 측의 응답을 받을 수 있어 빠른 웹 로딩이 구현되는 구조

## 2.4 DNS

DNS : 인터넷 호스트명을 클라이언트와 서버가 이해할 수 있는 IP 주소로 변환해주는 시스템

DNS 질의와 응답 성능이 나쁘면 웹 사이트 로딩에 영향을 주기 때문에 운영하는 웹 사이트 호스트명의 DNS 질의를 파악하고 개선해야한다. 

### 2.4.1 DNS의 작동 원리

도메인을 IP 주소로 질의하여 값을 받아오는 과정에는 도메인 구조 계층에 따라 각각의 DNS 서버들이 관여함

반복적 질의 (iterative query) : 계층형으로 나누어진 역할에 따라 순차적인 DNS 질의를 반복하여 값을 받아오는 프로세스 과정

### 2.4.2 사용 중인 다양한 도메인 확인 방법

- 크롬 개발자 도구-Source 항목

  하나의 웹 페이지에서 어떤 도메인들이 사용되고 있는지 파악할 수 있음.

  해당 페이지에서 사용중인 모든 도메인 호스트명 리스트와 그 도메인에서 어떤 콘텐츠를 가져왔는지 확인가능함.

### 2.4.3 웹 성능을 최적화하는 도메인 운용 방법

- 많은 도메인 호스트명을 사용하면 DNS 질의가 늘어나 응답시간이길어지고 웹 성능에 영향을 줌

  직접 개발한 내부 서비스에 도메인 분할을 하고 싶다면 상위 도메인을 동일하게 해 DNS 질의를 최대한 적게 만드는 것을 권장

- 공통된 상위 도메인을 사용하는 서비스들은 도메인 질의를 담당하는 네임 서버에 캐싱된 정보를 재사용할 수 있어 DNS 질의 시간을 단축시킴

  동일한 상위 도메인을 사용하면 HTTPS 사용을 위한 SSL 인증서를 와일드카드 형식으로 하나만 생성해도 모든 도메인에 사용가능

- HTML의 DNS 프리페치(prefetch) 기능을 사용하면 웹 페이지에 사용된 도메인들의 DNS를 조회하는 시간이 개선됨

  DNS 프리페치 : 하나의 웹 페이지에 다수의 도메인 호스트명이 섞여 있을 때 웹 문서 페이지를 여는 시점에 멀티스레드 방식으로 미리 DNS를 조회해 빠르게 IP주소를 불러오는 기술

  ```
  <!--DNS 미리 조회하기-->
  <link rel="dns-prefetch" href="//img.feokorea.com">
  ```

  link 태그의 지시자 구문에 'dns-prefetch'라는 명령어를 사용해 페이지 상단에서 미리 DNS를 조회하면 브라우저는 웹 콘텐츠를 다운로드함과 동시에 DNS를 조회하여 성능이 개선된다.

## 2.5 브라우저

HTTP,DNS를 사용해 사용자가 원하는 HTML,이미지,오디오,동영상 등의 웹 콘텐츠를 전달하는 소프트웨어.

### 2.5.1 브라우저의 역사와 특징

브라우저는 1990년 초반 웹이 만들어진 시대에 함께 개발되었다. 

- 넷스케이프, MS의 인터넷 익스플로러와 브라우저 전쟁

- HTML5와 CSS3.0의 등장

### 2.5.2 내비게이션 타이밍 API

웹 사이트의 성능을 측정하는 데 사용할 수 있는 데이터를 제공함. 종단간 대기 시간 정보를 제공함.

이전까지는 브라우저의 자바스크립트 기능을 이용해 웹 페이지가 열리는 시간과 로딩이 완료되는 시간 차이를 계산함으로써 웹 로딩 시간을 구할 수 있었음.