# 2 웹 최적화

## 2.1 웹 최적화란

<br>

- 최고의 웹 성능을 구현하기 위해 최고의 조건을 만드는 다양한 노력
- 웹 최적화는 프론트엔드 최적화, 백엔드 최적화, 프로토콜 최적화 세 가지로 나뉜다.

<br>

### 프론트엔드 최적화

<br>

- 프론트엔드 최적화는 리소스의 로딩, 렌더링과 관련이 있다.
- 사용자의 기기, 네트워크 품질, 브라우저 등에 따라 상대적으로 적용해야 한다.
- 프론트엔드 최적화에는 대표적으로 다음과 같은 방법이 있다.
  - 스크립트를 병합하여 네트워크 호출 수를 줄인다.
  - 스크립트, 이미지 등 리소스의 크기를 줄인다.
  - 캐싱을 활용한다.
  - DNS 조회를 최소화한다.
  - 페이지 prefetching

<br>

### 백엔드 최적화

<br>

- 웹 서버, 데이터 베이스, 로드 밸런싱, DNS 서버 등에 대한 최적화
- 백엔드 최적화에는 대표적으로 다음과 같은 방법이 있다.
  - 서버 증설
  - 캐싱
  - 데이터베이스 정규화
  - 로드밸런싱

<br>

### 프로토콜 최적화

<br>

- HTTP/HTTPS 프로토콜의 자체 효과를 극대화하면 리소스를 최대 속도, 최저 지연 시간으로 전달할 수 있다.
- 이를 위해 프로토콜을 업그레이드 하는 과정이 프로토콜 최적화이다.

<br>

## 2.2 TCP/IP 프로토콜

<br>

- 웹에서 사용하는 프로토콜인 HTTP는 TCP/IP 프로토콜의 일종이다.
- TCP 네트워크를 사용하는 대표적인 성능 지표는 대역폭과 지연 시간이다.
  - 대역폭은 단위 시간동안 보낼 수 있는 트래픽의 양을 의미한다.
  - 지연시간은 리소스를 전달하는 물리적인 시간을 의미한다.
  - 요청이 두 호스트를 왕복하는 데 걸리는 시간을 RTT(Round Trip Time)이라고 한다.

<br>

### TCP 혼잡 제어

<br>

- TCP 혼잡제어는 통신량을 조절해 TCP 네크워크가 혼잡해지지 않도록 하는 방식을 의미한다.
- TCP 네트워크의 통신량이 실제 처리량보다 많으면 TCP 혼잡 붕괴 현상이 나타난다.
- TCP 혼잡 제어 기술은 패킷 송신측이 네트워크에서 수용할 수 있는 양을 파악하는 방식으로 혼잡을 해결한다.
- 시시각각 편하는 네트워크 상태를 파악하는 혼잡제어 기술에는 다음이 있다.
  1. 느린 시작
     - TCP 연결이 시작되면 혼잡 윈도우(전송 가능한 버퍼의 양)의 초깃값을 작게 설정하여 전송한다.
     - 패킷이 정상적으로 도착할 때마다 곱셈방식으로 더 많은 패킷의 양을 늘린다.
     - 패킷 유실이 발생하기 전까지 이를 반복한다. 
     - 이를 통해 혼잡 윈도우의 크기를 파악하면 그 이상의 패킷을 보내지 않는다.
  2. 빠른 재전송
     - 순서상 먼저 도착해야하는 패킷이 도착하지 않으면 순서대로 잘 도착한 마짐가 패킷의 다음 순번을 ACK 패킷에 실어 보낸다.
     - 이러한 중복 ACK를 3번 받으면 재전송이 이루어진다.
     - 기본적으로 TCP 통신의 송신측은 설정된 타임아웃까지 ACK를 받지 못하면 혼잡이 발생한 것으로 파악한다.
     - 빠른 재정송은 타임아웃이 되지 않았어도 패킷을 재전송해 빠른 전송률을 유지하는 방법이다.
  3. 흐름 제어
     - 송신자가 데이터를 너무 빠르게 혹은 너무 많이 전송해 수신자의 버퍼가 오버플로우 되는 현상을 방지하는 기술이다.
     - 수신 속도를 송신 속도와 일치시키는 기술이다.
     - stop and wait, sliding window 등의 방법이 사용된다.

<br>

## 2.3 HTTP 프로토콜

<br>

- HTTP/1.1 버전부터 TCP/IP 연결 재사용과 파이프라인 기법이 적용되었다.

<br>

### HTTP 지속적 연결

<br>

- TCP의 3-way handshake 방식의 연결로 안정성을 추구할 수 있지만 많은 요청을 주고 받아야하는 경우에는 로딩 시간에 영향을 줄 수 있다.
- '지속적 연결'은 TCP 연결을 재사용하는 기술이다.
  - HTTP Connection헤더에 'keep-alive' 속성을 추가해 지속적 요청을 서버에 요청할 수 있다.(HTTP/1.0)
  - HTTP/1.1 에서는 Connection헤더를 사용하지 않아도 기본적으로 지속적 연결을 지원한다.
  - 따라서 TCP 연결을 끊어야할 때만 Connection헤더를 사용한다. (Connection: close)
- 서버와 TCP 연결을 유지하는 클라이언트를 무한정 늘릴 수는 없다.
  - 따라서 메인페이지와 같이 많은 사용자가 접속하는 페이지에서는 지속적 연결 여부를 고려해봐야한다.
- 멀티플렉싱 기술이 적용된 HTTP/2에서는 지속적 연결을 고민할 필요가 없다고 한다.(자세한 내용은 추후..)

<br>

### HTTP 파이프라이닝

<br>

- 먼저 보낸 요청에 대해 응답이 없어도 다음 요청을 병렬적으로 전달하는 기술이다.

<br>

## 2.4 DNS

<br>

- DNS의 질의, 응답 성능이 사이트 로딩 성능에 영향을 준다.

<br>

### DNS 작동원리

<br>
www.tanney.com을 질의한다고 가정하자
<br>

1. 로컬 DNS 서버로 질의 
  - 로컬 DNS는 사용자가 수동으로 설정한 DNS의 IP 혹은 ISP의 인근 서버이다.
  - 브라우저는 가장 먼저 로컬 DNS에 질의한다.
  - 만약 캐싱된 IP 주소가 있고 캐싱 주기가 남아있다면 이를 반환한다.
2. 루트 DNS 서버로 질의
  - 로컬에 캐싱된 정보가 없거나 캐싱 주기가 지났다면 로컬 DNS는 루트 DNS에 질의를 한다.
  - 루트 DNS는 .com 도메인 서버의 IP를 알려준다.
3. .com DNS 서버로 질의
  - 로컬 DNS는 .com DNS에 질의한다.
  - .com DNS는 tanney.com DNS의 IP를 알려준다.
4. tanney.com DNS 서버로 질의
  - 로컬 DNS는 tanney.com DNS에 질의한다.
  - www.tanney.com의 IP를 알려준다.

<br>

- 이와 같이 IP주소를 질의하는 과정은 도메인 구조 계층에 따라 각각의 DNS 서버에 질의하는 '반복적 질의'의 과정을 따른다.
- DNS 전문 업체의 서비스를 받거나 분산된 DNS 서버를 직접 운영하는 방식으로 성능을 향상시킬 수 있다.
- 타사의 서비스를 이용할 경우 해당 도메인 서버 성능에 영향을 받는다.
- DNS 질의를 할 도메인 수 자체를 줄이는 것도 방법이다.

<br>

### DNS 최적화

<br>

- 자체 서비스들의 경우 상위 도메인을 동일하게 해 DNS 질의를 최대한 적게 만드는 것이 좋다.
- HTML의 DNS prefetch 기능을 사용할 수도 있다.

<br>

## 2.5 브라우저

<br>

### 네비게이션 타이밍 API

<br>

- 웹 사이트의 성능을 측정하는 데 사용하는 데이터를 제공한다.
- window.performance 객체를 통해 사용할 수 있다.