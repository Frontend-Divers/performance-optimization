# Chapter 06 캐시 최적화

## 6.1 캐시

- 필요한 데이터를 매번 서버에서 가공해 제공하는 것은 그 자체로 오랜시간이 소요된다.
- 만약 사용자의 같은 요청에 응답하는 리소스가 항상 똑같다면 서버가 매번 같은 작업으로 데이터를 가공하지 않아도 된다.
- 이때 특정 요청에 대한 데이터를 메모리나 메모리에 가까운 저장소에 Key, Value 형태로 저장하고 인덱스로 빠르게 찾아 응답한다면 서버의 부담이 줄고 응답 시간도 크게 단축할 수 있다.
- 이처럼 콘텐츠 요청에 빠르게 응답하기 위해 서버와 클라이언트 사이에서 응답 콘텐츠의 사본을 저장하는 공간을 `캐시`라 한다.
- 캐시는 보통 클라이언트와 서버 사이에 존재하며 서버의 성능을 크게 향상시키는 역할을 한다.
- 현재 웹 아키텍처에는 다양한 캐시 서버가 존재한다.
  - 부라우저가 사용하는 브라우저 캐시
  - 서버에서 성능 향상을 위해 별도로 사용하는 리버스 프록시 형태의 캐시 서버

- 캐시 서버는 원본 서버뿐만 아니라 프록시 서버, ISP 라우터 등 다양한 위치에 존재하며 네트워크 대역폭 및 비용 절감을 위해 사용된다.

<br>

## 6.2 웹 캐시 동작 원리

- 웹 캐시를 바르게 사용하려면 동작 원리를 잘 이해해야한다. HTTP 통신을 이해해야 콘텐츠를 캐시하는 과정을 이해할 수 있다.
  - 웹 캐시는 웹 서버와 웹 브라우저 중간에 존재하면서 최초 원본 콘텐츠 요청을 최종 서버에 보내 응답을 받은 후 그 복사본을 만들어 저장하고 사용자에게 응답한다.
  - 이후 같은 콘텐츠에 대한 요청이 오면 최종 서버에서 원본 서버를 가져오는 대신 복사본을 사용자에게 전달한다.
  - 그 결과 원본 서버로의 트래픽을 줄이고 사용자의 요청에 대한 반응 속도를 빠르게 한다.

<br>

### 6.2.1 HTTP

- 캐시 서버는 HTTP/1.1 규격을 기반으로 동작하므로 HTTP에 대한 기본 지식을 먼저 이해해야 한다.
  - HTTP는 인터넷에서 데이터를 주고받기 위한 클라이언트/서버 모델을 따르는 프로토콜이다.
  - OSI 7계층 모델의 마지막 7계층인 Application 레벨의 프로토콜이며 TCP/IP 위에서 동작한다.
  - etc.
- HTTP 메시지는 크게 헤더와 페이로드로 구분된다.
  - 헤더에는 메시지를 전송할 호스트명, URL 패스 등 메시지 전송 및 처리에 필요한 데이터들이 포함되어 있다.
  - 페이로드는 html, 이미지 등 서버가 실제 전송하고자 하는 데이터를 포함한다.

<br>

### 6.2.2 HTTP의 캐시 제어 방식

- HTTP/1.1부터 명시적으로 캐시를 제어할 수 있는 헤더를 추가했는데 이것이 Cache-Control 헤더이다.
- HTTP/1.1에서는 캐시를 제어하는 목적을 크게 두 가지로 정의한다.
  - 원본 서버로의 요청 수를 최소화한다. 이는 네트워크 왕복 수를 줄여 결과적으로 사용자 요청에 대한 응답 속도를 단축할 수 있다.
  - 완전한 콘텐츠를 응답하지 않아도 된다. 이는 네트워크 대역폭과 리소스 낭비를 줄이고 비용을 효율화한다.

<br>

**HTTP 헤더를 통해 위 두 가지 목적을 어떻게 달성할 것인지 살펴보겠다.**

- Expire
  - HTTP/1.0은 Expire 헤더를 사용해 원본 서버 콘텐츠의 유효 기간을 지정하도록 정의한다. 이때 원본 서버는 Expire와 Date 헤더를 함께 보내야 하며 Date 헤더는 요청에 대한 응답이 작성된 시점을 표시한다. 캐시는 간단하게 Expire 날짜에서 Date 날짜를 빼는 것으로 해당 응답의 캐시 유지 시간을 결정할 수 있다.
  - Expire 헤더는 캐시를 명시적으로 제어하지는 않지만 브라우저를 포함한 대부분 캐시 서버에서 콘텐츠를 언제까지 저장할 것인지 판단하기 위해 사용한다.

- Cache-Control: max-age
  - HTTP/1.1에서는 Cache-Control: max-age라는 헤더로 콘텐츠의 캐시 유지 시간을 정의한다.
  - 원본 서버는 이 헤더를 사용해 캐시에서 특정 콘텐츠를 얼마나 오래 유지하고 있어야 하는 지 명시적으로 설정한다.
  - 이 기간이 지나면 캐시 서버는 원본 서버에 해당 콘텐츠 변경 여부를 체크하거나 새로 갱신해야한다.
  - Expire 헤더는 만료 일자를 지정하는 반면 Cache-control: max-age는 유효 기간을 지정한다.

-  Cache-Control: s=maxage
  - s-maxage를 이용하면 사용중인 모든 CDN의 캐시 주기를 일괄적으로 설정하거나 변경할 수 있다.
- ETag
  - ETag(Entity Tag) 헤더는 원본 서버가 리소스를 식별하기 위해 부여하는 고유 번호이다. 캐시 서버에서는 ETag를 사용해 원본 서버의 리소스가 시간이 지나 만료되었는지, 캐시된 리소스를 새로 갱신해야 하는지 여부를 명확히 판단할 수 있다.
- Cache-Control: public
  - public으로 설정하면 그 응답은 모든 캐시 서버에 캐시될 수 있고 사용자 제한 없이 모든 사용자에게 응답이 전달될 수 있다.
- Cache-Control: private
  - private으로 설정하면 HTTP 요청에 대한 응답은 요청한 사용자만 캐시할 수 있고 CDN 같은 범용 캐시 서버에서는 캐시할 수 없다.
  - private은 원본 서버가 일부 응답을 특정 사용자에게만 전달하는 데 목적이 있으므로 캐시 콘텐츠가 공유되면 안 된다.
- Cache-Control: no-cache
  - no-cache 지시자는 요청과 응답 헤더에 모두 사용할 수 있지만 약간의 의미 차이가 있다.
    - 첫 번째로, 요청 헤더에 있을 경우 브라우저는 원본 서버나 그 중간에 존재하는 캐시 서버들에게 '캐시된 응답을 받지 않겠다'는 메시지를 전달하는 것과 같다. 이 지시자가 있으면 중간에 있는 캐시 서버들은 당연히 이 요청을 원본 서버에 그대로 전달해 원본 서버로부터 최신의 응답을 받아 사용자에게 전달해야한다.
    - 두 번째로, 응답 헤더에 포함되면 원본 서버가 캐시 서버들에게 캐시된 응답을 보내기 전 원본 서버를 항상 확인하도록 강제한다. 매 요청마다 캐시된 복사본을 원본 서버와 검증하라 강제하는 것이다.
- Cache-Control no-store
  - HTTP 요청 또는 응답 헤더에 모두 사용할 수 있고 쓰임새도 동일하다. 서버가 로컬 저장소에 메시지를 저장하지 않도록 지시하는 것이다.
  - 이 지시문의 목적은 캐시 데이터의 예기치 않은 유출을 방지하려는 것이다.

<br>

### 6.2.3 캐시 유효성 체크

- 캐시된 콘텐츠에 아무런 변화가 없는 상황에서 완전한 응답을 다시 만들어 보내는 비효율적인 요청/응답을 방지하고자 HTTP 표준은 조건부 요청이라는 메커니즘을 정의한다.

  - 이 메커니즘은 저장된 응답  TTL이 만료되었을 경우 캐시가 항상 원본 서버에서 완전한 콘텐츠를 받아오는 대신 TTL 주기 동안 콘텐츠에 변화가 있을 때에만 새 응답을 만들도록 요청한다.
  - 원본 서버에서 조건부 요청을 받았다면 해당 콘텐츠에 변경이 있을 때 200 응답 코드와 함께 변경된 콘텐츠를 응답 본문에 포함해 보낸다. 대신 변경이 없다면 응답 본문 없이 304코드만 헤더에 설정하여 보내는데 응답에 본문이 없으므로 서버와 네트워크 자원 낭비를 방지할 수 있다.

- 조건부 요청을 보낼 때는 시간을 기반으로 보내는 방법과 콘텐츠를 기반으로 보내는 방법이 존재한다.

  **시간 기반의 조건부 요청**

  - 시간 기반의 조건부 요청이란 어떤 요청에 대한 원본 서버의 콘텐츠가 캐시에 저장된 후 변경되었는지 여부를 콘텐츠의 최종 본경 시간 중심으로 확인하는 방법이다.

  **콘텐츠 기반의 조건부 요청**

  - 콘텐츠 기반의 조건부 요청이란 어떤 요청에 대한 원본 서버의 콘텐츠가 캐시에 저장된 후 변경되었는지 여부를 콘텐츠 고윳값 중심으로 확인하는 방법이다.
  - 콘텐츠 내용이 약간이라도 수정되면 해시값도 변하기 때문에 이 값을 비교해 콘텐츠의 변경 여부를 파악할 수 있다.

<br>

### 6.2.4 캐시 콘텐츠 갱신

- 웹 사이트가 개편되었거나 콘텐츠를 급하게 변경했다면 캐시에 저장된 복사본들을 강제로 갱신해야 사용자에게 정상적인 웹 페이지를 서비스할 수 있다.
- 캐시에 저장된 내용을 갱신하기 위해서 다음과 같은 두 가지 방법을 사용할 수 있다.
  - **퍼지**
    - 퍼지는 저장소를 완전히 지우는 방식으로 대부분의 캐시 서버가 캐시를 모두 지우는 명령이나 API를 제공한다.
    - CDN을 비롯한 캐시 서버에서 한꺼번에 많은 콘텐츠를 퍼지하려면 원본 서버에 충분한 자원이 있는지 확인하는 등 주의를 기울여야한다.
  - **무효화**
    - 무효화는 캐시 저장소를 완전히 지우기보다 조건부 요청을 통해 캐시된 리소스들 중 변경이 있었던 리소스들만 새로 갱신하는 방법이다.
    - Cache-Control 헤더를 사용해 캐시 서버의 내용을 강제로 무효화할 수 있다.
    - 퍼지와 다르게 실제 변경된 리소스에 한해서만 전체 콘텐츠가 반환되므로 네트워크 대역폭 낭비를 크게 줄일 수 있다.

<br>

## 6.3 캐시 최적화 방안

- 캐시 사용을 최대화할 수 있는 3가지 기본 원리는 다음과 같습니다.
  - 최대한 많이 캐시하라
  - 최대한 오래 캐시하라
  - 최대한 가까이 캐시하라

<br>

### 6.3.1 캐시 가능한 콘텐츠 구분하기

- 캐시하기 어려운 콘텐츠는 아래와 같이 분류할 수 있다.
  - 개인화된 콘텐츠
  - API 호출이나 Ajax 요청에 대한 콘텐츠
  - Beacon 전달 또는 쿠키 설정을 위한 호출

<br>

### 6.3.2 올바른 캐시 정책 설정하기

- 캐시 정책을 세우는 것은 캐시할 콘텐츠들의 성격을 파악하고 그룹화하는 것과 같습니다. 아래와 같은 순서를 참고해 하위 그룹을 나누고 캐시 정책을 정한다.
  - 먼저 캐시할 수 있는 콘텐츠인지 판단한다.
  - 캐시할 수 있는 콘텐츠들은 매번 원본 서버에 변경 사항을 확인해야 하는지 판단한다.
  - 캐시할 콘텐츠들의 성격을 판단한다.
  - 캐시 주기를 설정하고 max-age를 추가한다.

<br>

### 6.3.3 캐시 주기 결정하기

- 기본적인 캐시 정책이 결정되면 구체적으로 얼마 동안 캐시할 것인지 결정해야한다.
- 캐시 주기는 아래와 같은 방법으로 결정할 수 있다.
  - 캐시 주기는 콘텐츠 타입별로 다르게 설정할 수 있다.
  - 만약 링크 변경 없이 이미지 내용만 바꿔야 한다면 무효화 방식으로 해당 이미지만 캐시에 업데이트 한다.
  - 모든 정적 파일에 대해 캐시 주기를 길게 설정하고, 수동으로 캐시 주기를 관리하는 방법도 있다.

<br>

### 6.3.4 캐시에 적합한 디렉터리 구조 구성하기

- 웹 콘텐츠의 구성 요소들을 파악하고 콘텐츠별 개시 정책을 정의했다면 캐시 친화적 디렉터리 구조를 구성하는 것을 권한다.
- 캐시에 적합한 디렉터리 구조를 구성하려면 아래와 같은 방법으로 한다.
  - 첫 번째로 캐시할 수 있는 콘텐츠들을 별도의 폴더에 분류해 관리한다.
  - 두 번째로 캐시 주기별로 나누어 구성한다.
  - 세 번째로 동일한 파일을 여러 곳에 분산시키지 않아야한다. 웹 사이트를 구성하다 보면 상대 경로를 사용하려고 같은 파일을 여러 폴더에 복제하여 사용하는 경우가 있다. 이는 원본 소스를 관리하는 데도 문제가 되지만 캐시에도 도움이 되지 않는다. 대부분의 캐시 서버는 URL을 키 값으로 하여 동작하므로 복제 생성되는 URL 수만큼 캐시에도 복사본이 생성되기 때문이다.

<br>

### 6.3.5 캐시 키 올바르게 사용하기

- 캐시 키란 캐시 서버가 원본의 복사본을 저장하고 빠르게 조회하기 위해 사용하는 키 값을 말한다.

<br>

​	**캐시 오염과 캐시 충돌**

- 원본 서버에 하나의 원본 파일만 존재하는데 캐시에 복사본이 여러 개 존재하는 것을 캐시 오염이라 한다.
- 캐시 충돌이란 요청 URL이 하나인데 브라우저 환경에 따라 서버에서 제공하는 응답이 달라져 결국 최초 요청한 브라우저의 응답만 캐시되는 것을 의미한다.

<br>

​	**캐시 오염 제거**

- 캐시 오염은 최종 사용자에게 영향을 주지는 않지만 캐시 서버의 효율성에 큰 영향을 미칠 수 있다. 또한 캐시가 퍼지된 경우 원본 서버에 예기치 않은 트래픽 부담을 줄 수 있다. 

- 아래는 이러한 캐시 오염을 피하는 방법이다.

  - 첫 번째로 URL에 붙은 특정 쿼리 스트링 값이 달라지더라도 응답이 항상 같다면 캐시 키에서 쿼리 스트링을 무시하도록 설정해야한다.

  - 두 번째로 쿼리 스트링의 순서를 동일하게 정렬한다. 쿼리 스트링 순서가 달라져도 캐시는 이들을 다르게 인식한다. 따라서 쿼리 스트링을 사용할 때는 오름차순이나 내림차순으로 항상 동일하게 순서를 정렬해 호출하도록 설정해야한다.

  - 세 번째로 Vary 헤더를 바르게 사용해야한다. Vary 헤더가 잘못 사용되었을 때 캐시는 같은 페이지의 복사본을 여러 가지 캐시 키로 다르게 저장하기도 한다. 꼭 필요한 경우가 아니면 Vary 헤더를 사용하지 않거나 Cache-Control: private을 사용해 중간 캐시 서버에는 캐시하지 않도록 하는 것을 추천한다.

    > Vary 헤더는 단어 그대로 서버의 응답이 상황에 따라 달라지는 것을 의미한다.

  **캐시 충돌 방지**

- 캐시 충돌은 동적 페이지를 캐시할 때 주로 발생한다.

- 이 현상을 피하려면 기본적으로 동적 페이지에는 캐시를 적용하지 않아야한다. 

- 일부 동적 페이지에 캐시를 사용하고자 한다면 Cache-Control: private으로 사용자 브라우저에만 캐시하여 페이지 로딩 시간을 단축할 수 있다.

<br>

### 6.3.6 CDN 사용하기

- 캐시 효율화를 위한 3원칙 중 마지막은 사용자에게 가깝게 캐시하라는 것이다.

- CDN 서비를 사용하면 세계 여러 지역 데이터 센터들에 리버스 프록시 캐시 서버를 두고 필요한 정적 콘텐츠들을 저장해놓을 수 있다.
- 또한 사용자가 관련 콘텐츠를 요청할 때 사용자와 가장 가까운 캐시 서버에서 해당 콘텐츠가 서비스되므로 시간 지연 없이 빠르게 웹 페이지를 로딩할 수 있다.

<br>

## 6.4 동적 콘텐츠 캐시

- 서버에서 동적 콘텐츠를 처리하는 시간이 전체 응답 시간 중 많은 부분을 차지한다. 따라서 이들을 캐시할 수 있다면 사용자가 체감하는 응답 시간을 단축시킬 뿐만 아니라 서버의 리소스도 절약할 수 있다.

<br>

### 6.4.1 동적 콘텐츠 캐시

- 동적 콘텐츠를 사용자에게 전달하기 위해 원본 서버는 아래의 두 가지 방법을 사용한다.
  - 동적 정보를 쿠키에 넣어 보낸다.
    - 요청 쿠키, 헤더 혹은 쿼리 스트링에 동적 콘텐츠에 대한 정보가 있으면 이 정보들을 캐시 키에 추가함으로써 동적 콘텐츠를 캐시할 수 있다. 사용자 로그인 페이지는 로그인 정보가 쿠키에 있는 경우와 없는 경우로 그룹화하고 쿠키가 없을 때만 캐시한다.
    - 이때, 첫 번째로 보안에 주의해야한다.
    - 두 번째로 캐시 서버 용량에 유의해야 한다. 개인화된 콘텐츠가 지나치게 많아서 캐시 서버의 용량이 소진되면 이전 객체를 지우기 위해 CPU 사용량이 늘어나 결국 캐시 효율이 떨어진다.
  - Ajax 요청으로 관련 정보를 동적으로 받아온다.

<br>

### 6.4.2 POST 응답 캐시

- POST 메소드를 사용하면 HTTP 페이로드에 쿼리 스트링 내용을 포함해 보내므로 데이터 크기에 제한이 없다. 또한 타인이 브라우저를 통해 쉽게 볼 수 없어 보안 측면에서도 상대적으로 안전한다.
- 따라서 POST 메소드는 보통 브라우저 캐시나 조회 이력에 남기지 않고 캐시 서버에 캐시되어서도 안 된다.
- 만약 입력 매개 변수가 동일할 때 서버로부터 항상 동일한 응답이 반환된다면, 또 그 응답 내용이 보안 측면에서 공개되어도 안전한 내용이라면 이 POST 요청/응답 역시 캐시할 수 있다. 단 캐시 키에 요청 매개 변숫값들이 모두 포함되어야 캐시 오염, 캐시 충돌 같은 오류 현상을 방지할 수 있다.

<br>
