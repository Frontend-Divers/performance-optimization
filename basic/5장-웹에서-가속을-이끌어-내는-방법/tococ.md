# Chapter 05 웹에서 가속을 이끌어 내는 방법

## 5.1 웹 브라우저 현황 알아보기

- 웹 페이지를 경량화하고 요청 수를 줄여도 HTML을 화면에 그리는 것은 결국 웹 브라우저이다. 따라서 브라우저가 페이지를 화면에 렌더링하는 방식을 이해하고 이를 최적화하는 것이 프론트엔드 최적화의 핵심이다.

- 웹에는 다양한 브라우저가 존재하고 그 중에서도 크롬 브라우저가 현재 전 세계에서 가장 많이 사용되고 있다.

- 여러 가지의 브라우저가 존재하고 있고 각각의 브라우저는 각자의 특징을 가지고 작동하지만 웹페이지를 전송하고 렌더링하는 방식에는 큰 차이가 없이 표준 방식으로 작성된 html을 해석하고 이에 맞도록 객체를 생성하며 화면 크기에 맞추어 원하는 그림을 그릴 수 있다.

<br>

## 5.2 웹 브라우저 동작 이해하기

- 사용자가 입력창에 접속하고자 하는 웹 사이트 주소를 입력함으로써 브라우저의 동작이 시작된다.
  
  - 브라우저는 가장 먼저 도메인 서버와 통신하여 접속하려는 호스트의 IP를 찾는다.
  
  - 해당 아이피를 가진 서버와 통신을 시도해 TCP 연결을 맺는다.
    
    - HTTPS에선 암호화된 연결을 생성하려는 협의 단계가 더 추가된다.
  
  - 연결이 맺어지면 브라우저는 서버로부터 필요한 리소스들을 다운로드해 이를 화면에 표현한다.

<br>

- 브라우저가 리소스를 다운로드할 때는 먼저 방문 페이지의 HTML을 서버에 요청해 다운로드한다. 그리고 HTML의 구문을 분석하면서 HTML 태그에 참조된 CSS, 자바스크립트, 이미지, 폰트 등의 하위 리소스들을 차례로 다운로드한다.

- 브라우저는 리소스들을 다운로드하며 동시에 개발자가 원하는 대로 화면에 페이지를 그리는 작업을 수행한다. 이렇게 화면을 그리는 일련의 절차를 렌더링 경로라고 한다.

<br>

### 5.2.1 브라우저 아키텍처

- 아래는 브라우저의 구성 요소들이다.
  
  - 유저 인터 페이스
    
    - 사용자가 브라우저를 통해 상호 작용할 수 있도록 돕는다.
  
  - 브라우저 엔진
    
    - 유저 인터페이스와 렌더링 엔진 사이에서 렌더링 상태를 조회하고 렌더링 작업을 제어하기 위한 인터페이스를 제공한다.
  
  - 렌더링 엔진
    
    - HTML을 분석하여 그대로 표현하거나 CSS를 분석해 웹 페이지를 멋지게 꾸미기도 하는 등 실제 웹 콘텐츠를 원하는 대로 브라우저 창에 그리는 역할을 한다.
  
  - 네트워킹
    
    - 네트워크를 통해 HTTP 요청을 보내고 응답받는 역할을 한다.
  
  - UI 백엔드
    
    - 콤보박스, 드롭박스 등 기본적인 UI 컴포넌트들을 제공한다.
  
  - 자바스크립트 해석기
    
    - V8, Spider Monkey 등의 엔진을 사용하여 자바스크립트를 분석하고 해석한다.
  
  - 데이터 저장소
    
    - 데이터 지속성을 유지하기 위한 컴포넌트이다.
    
    - 가장 흔하겡는 쿠키 값을 로컬 디스크에 저장한다.

- 사용자 요청을 처리하고 웹 사이트를 표현하기 위해 위의 모든 컴포넌트들이 유기적으로 동작한다. 실제로 HTML을 처리해 화면에 렌더링하는 컴포넌트는 `렌더링 엔진`이다. 

<br>

### 5.2.2 중요 렌더링 경로

- 렌더링 엔진이 웹 페이지를 구문 분석해 화면에 표현하는 일련의 작업은 선후 관계가 비교적 명확하므로 단일 스레드에 의해 수행된다.
  
  - ex) HTML이 해석되지 않으면 CSS와 자바스크립트가 수행될 수 없고, 객체 모델이 만들어지지 않으면 브라우저가 화면을 구성할 수 없으며, 화면 구성을 하지 못하면 결국 페이지를 그릴 수 없다. 따라서, 일련의 작업을 브라우저가 어떤 순서로 처리하는지 이해하는 것은 웹 최적화뿐만 아니라 웹 개발에 있어서도 매우 중요하다.

- 아래의 과정을 통해서 렌더링이 된다.
  
  - **DOM 트리 생성**
    
    - 브라우저는 가장 먼저 다운로드한 HTML의 구문을 분석해 태그를 하나하나 해석하여 DOM이라는 객체 모델로 변환한다.
      
      > DOM은 객체 지향적 프로그램 언어들로 HTML이나 XML 형태의 마크업 문서들을 손쉽게 프로그래밍하기 위해 표준으로 규정한 프로그램 인터페이스이다.
    
    - DOM은 다른 프로그래밍 인터페이스와 마찬가지로 객체 속성과 메소드 그리고 이벤트 등을 정의한다.
    
    - 브라우저 구문 분석기는 위에서부터 순차적으로 HTML을 분석하며 부모 노드와 자식 노드와의 관계를 파악해 DOM 트리를 생성한다.
  
  <br>
  
  - **CSSOM 트리 생성**
    
    - CSSOM은 DOM과 비슷하게 CSS를 처리하기 위한 트리 구조의 프로그래밍 인터페이스이다. 브라우저가 HTML을 구문 분석하며 CSS를 참조하는 링크를 만나면 해당 CSS 리소스를 다운로드하고 구문 분석기가 CSS를 분석하기 시작한다.
    
    - HTML과 다르게 CSS는 구문 분석에는 엄격한 구문 검사가 적용된다. 그렇다보니 사용하는 구문 분석기와 동작 스레드도 다르다. 따라서 HTML 구문 분석 과정이 CSS 분석에 의해 방해받지 않는다.
  
  <br>
  
  - **렌더 트리 생성**
    
    - DOM 트리와 CSSOM 트리 구문 분석이 완료되면 브라우저는 두 개의 트리를 병합해 렌더 트리를 생성한다. DOM과 CSSOM을 기반으로 렌더링을 위한 최종 정보를 가진 렌더 객체들을 생성해 이들의 상하 관계를 트리 모양으로 구성한 것이 렌더 트리이다.
  
  <br>
  
  - **레이아웃**
    
    - 레이아웃은 렌더 트리 노드들의 위치 정보가 계산되는 단계이다. 렌더 객체는 사각형 영억을 표시하므로 브라우저 창의 맨 왼쪽 위에서 시작하여 아래, 오른쪽으로 이동하며 각 사각형 영역의 너비와 높이를 계산한다.
    
    - 렌더 트리의 루트 노드부터 계산이 시작되는데 루트 노드의 너비는 뷰포트의 크기로 지정된다.
  
  <br>
  
  - **페인트**
    
    - 페인트는 렌더 트리 정보를 바탕으로 브라우저 창에 표현하는 단계이다.
    
    - 이미 렌더링을 위한 정보가 모두 준비되어있으므로 GPU를 이용해 그리기만 하면 된다.
    
    - 자바스크립트는 DOM과 CSSOM을 동적으로 변경할 수 있으며 이 경우 렌더 트리가 변경되고 레이아웃, 페인트 단계가 다시 수행된다.

<br>

## 5.3 브라우저 렌더링 최적화하기

### 5.3.1 DOM 최적화하기

- HTML은 구문 체크에 관대하므로 작성 시 잘못된 습관이나 실수에 의해 문법 오류가 발생해도 브라우저에는 정상적으로 표현되는 경우가 많다.

- 이렇게 다양한 오류를 포용하기 위해 브라우저는 잘 알려진 수많은 오류 사항에 대한 예외 처리 방안을 구현한다.
  
  - ex) 제한된 숫자 이상 중첩된 태그가 많거나 태그를 열고 닫지 않거나 테이블 안에 테이블이 겹치는 등의 오류가 발생하면 내부 알고리즘에 의해 중첩된 태그를 제거하고, 적절한 위치에서 태그를 닫고, 겹친 테이블을 분리하는 일련의 작업을 수행한다. 따라서, 웹 페이지 내에 오류가 많을수록 브라우저는 예외 처리를 위해 더 많은 메모리와 CPU 파워를 소모한다.

- **HTML의 구문 오류를 최소화하고 간소화하는 것이 웹 사이트 성능을 향상시키는 기본적이고도 간단한 방법이다.**

- 과도하게 HTML 태그를 중첩 사용하는 행위도 피해야한다.
  
  - 태그가 중첩되어 HTML 문서 구조가 복잡하게 작성되어 있으면 자바스크립트에 의해 스타일이 변경될 때 각 태그의 레이아웃을 다시 계산하고 재구성하는 데 더 많은 리소스와 시간이 소요된다. 

<br>

### 5.3.2 자바스크립트와 CSS 배치하기

- HTML 구문 분석기가 순차적으로 HTML을 해석하는 중 자바스크립트를 만나면 이를 다운로드하고 수행이 완료될 때까지 DOM 생성 작업을 중단한다. 자바스크립트에 의한 변경이 완료되기를 기다리는 것이다.

- 하지만 그 시점에 특정 CSS에 대한 구문 분석 처리 및 CSSOm 생성 작업이 진행 중이라면 자바스크립트가 변경하려는 스타일 시트가 아직 생성되지 않았을 수 있다. 그러므로 해당 자바스크립트는 CSSOM 생성이 완료될 때까지 수행을 중지하고 대기한다.

- 이러한 CSS와 자바스크립트의 렌더링 방해를 피하려면 CSS를 최대한 소스 위쪽에 배치하여 CSSOM이 가능한 빨리 생성되도록 한다. 그리고 자바스크립트는 최대한 HTML 아래쪽에 배치하여 DOM과 CSSOM이 모두 생성된 이후에 수행될 수 있도록 하는 것이 가장 효과적이다.

<br>

### 5.3.3 자바스크립트 최적화하기

- 자바스크립트를 HTML 아래쪽에 배치하는 것만으로도 렌더링의 방해 요소가 많이 사라지지만 이는 충분하지 않다.

- 자바스크립트가 전체 페이지 로딩 시간에 영향을 주는 것을 막으려면 자바스크립트 수행이 렌더링 스레드를 방해하지 않도록 별도 스레드로 자바스크립트를 수행시켜줘야한다.
  
  - 자바스크립트에서 제공하는 관련 속성을 활용할 수 있다. (**async, defer**)
    
    - async 속성은 HTML 구문 분석과 동시에 자바스크립트를 다운로드하고 수행되도록 한다.
    
    - defer 속성은 구문 분석 중에 별도의 스레드로 자바스크립트를 다운로드하고 구문 분석이 끝난 이후에 수행되도록 한다.

<br>

### 5.3.4 CSS 최적화하기

- 브라우저는 CSS가 구문 분석되고 CSSOM이 만들어지기까지 렌더링을 멈추므로 CSS는 렌더링 순위가 가장 높으면서 동시에 렌더링을 가장 방해하는 리소스이다.

- CSS는 필요한 정보만 빠르게 다운로드하고 실행해야 브라우저 렌더링을 가속시킬 수 있다.

- 이를 위해 첫 번째로 CSS를 적절히 분리하여 필요한 페이지에 필요한 CSS 파일만 포함해야한다.

- 두 번째로는 첫 화면에 사용될 CSS 파일과 숨겨진 화면에 사용될 CSS 파일을 분리해 후자의 CSS는 지연수행 시켜야한다.

- 필요한 CSS만 다운로드하려면 미디어 쿼리를 활용할 수 있다. 이때 미디어 쿼리의 조건과 함께 해당하는 CSS 파일을 링크시키면 조건에 맞지 않는 파일은 다운로드하지 않는다.

<br>

### 5.3.5 이미지 로딩 최적화하기

- 웹 최적화에 있어 이미지 압축은 필수일 정도로 이미지 로딩 최적화는 다른 방법들에 비해 효율적이다.

- CSS에 의해 이미지가 숨겨질 것을 미리 알고 있다면 브라우저가 그 이미지를 다운로드하지 않음으로써 페이지 로딩을 더 가속화할 수 있다. 하지만 DOM과 CSSOm이 별도 분석되고 생성되기 때문에 브라우저는 이를 미리 알지 못하고 DOM 트리에 나타난 객체들을 모두 다운로드한다.

- **그렇다면 화면 레더링에 필요하지 않은 이미지를 다운로드하지 않으려면 어떻게 해야할까?**
  
  - 첫 번째로 만약 그 이미지가 웹 사이트의 주요 이미지가 아니라면 CSS의 background-image 속성을 사용해 원하지 않는 다운로드를 피할 수 있다. 브라우저가 CSS를 분석할 때 숨겨질 이미지는 미리 알고 다운로드하지 않기 때문이다.
  
  - 두 번째로 자바스크립트를 이용한 지연 로딩 방식을 적용해 불필요한 다운로드를 피한다.
    
    - 하지만, 이미지 지연 로딩이 브라우저 로딩 속도 개선에 효과적일 수 있으나 사용자 경험 개선에 항상 도움이 되지는 않는다. 모든 이미지에 지연로딩을 적용하면 브라우저의 프리로더가 이미지를 다운로드할 수 없으므로 오히려 성능을 저해하는 요소가 된다.
    
    - 따라서, 지연 로딩은 첫 화면에 등장하지 않거나 숨겨진 이미지들을 다운로드하는데만 사용하면 좋겠다.
  
  - 세 번째로 Progreesive JPG를 활용할 수 있다. Progressive JPG는 고품질 이미지를 한 번에 전송하지 않고 분할 전송하는 방식으로 브라우저에서는 초기에 저품질 이미지가 보이지만 점차 원래 품질을 회복한다.

<br>

## 5.4 도메인 분할 기법 이용하기

- 도메인 분할 기법은 여러 도메인을 소유한 경우 웹 콘텐츠를 병렬적으로 동시에 다운로드할 수 있도록 하는 방법이다.

- 브라우저는 HTTP/1.1 프로토콜 하에서 동일 도메인에 순차적인 다운로드 방식을 사용한다.

- 도메인 분할은 달리 보면 HTTP/1.1 프로토콜 하에서 브라우저의 제약을 피하는 방식이다. 브라우저는 동일 호스트명의 동시 연결 개수를 제한하고 있는데, 한 도메인다 6~13개의 TCP 연결들을 동시 생성해 여러 리소스를 한 번에 다운로드할 수 있도록 허용한다.

- 도메인 분할 기법을 이용하면 사이트 전체의 쿠키 사이즈를 축소할 수 있는 장점도 있다. 

- 도메인을 여러 개로 분할하는 방법은 기술적으로 어렵지 않지만 도메인을 몇 개로 운용하는 것이 최적인지 결정하는 데는 좀 더 면밀한 계획과 테스트가 필요하다. 하나의 웹 페이지에 포함된 리소스 개수가 얼마나 많은가에 따라 추가할 서브 도메인의 숫자를 결정해야한다.

- 너무 많은 도메인을 추가하면 오히려 브라우저의 성능을 저하시킬 수 있으므로 주의해야한다.
  
  - 동시 다운로드 숫자가 많아질수록 브라우저는 더 많은 CPU 리소스를 사용하고 CPU 리소스가 한계에 도달하면 오히려 다운로드 속도를 느리게 만들기 때문이다.
  
  - 또한 브라우저는 각 도메인에 대한 DNS 조회를 수행하고 TCP 연결을 생성하며 생성된 도메인에 대한 연결을 유지해야 하므로 이는 결국 페이지 로딩 속도를 현저히 떨어뜨린다.

- 사용할 도메인의 개수가 정해지면 그 수에 맞도록 리소스들을 균등 분할하는 것이 좋다.

<br>

### 5.4.1 도메인 분할 기법과 HTTP/2

- 도메인 분할 기법이 고안된 이유는 HTTP/1.1의 가장 큰 문제점으로 지적되어 온 Head Of Line Breaking 현상 때문이다. HTTP/1.1에서 클라이언트와 서버 간의 연결은 마치 하나의 차선만 있는 도로와 같다.
  
  - 클라이언트는 하나의 요청을 서버에 보내고 그에 대한 정상적 응답을 받은 후에야 다음 요청을 서버에 보낼 수 있다. 이 문제점은 HTTP/2의 멀티 플렉싱 기술로 해결되어 도메인 분할 기법을 사용할 이유도 자연스럽게 사라졌다.

- 최근 사용되는 브라우저들은 HTTP/2의 기능을 저해하지 않으면서 다중 도메인을 사용할 수 있는 방안을 제공한다. 바로 TCP 연결을 병합하는 방식이다.

- 연결 병합은 브라우저가 첫 번째 도메인과 맺은 TCP 연결을 나머지 도메인에 재사용하는 방식으로 이 기술이 적용되기 위해서는 몇 가지 고려해야할 사항이 있다.
  
  - 브라우저가 DNS를 확인할 때 각 도메인은 모두 동일한 IP 주소를 반환해야한다.
  
  - 동일한 인증서를 사용해야한다.

<br>

## 5.5 사용자 경험 개선하기

- 브라우저의 성능 지표만 향상시킨다고 해서 실제 사용자가 느끼는 성능이 향상되는 것은 아니다. 이를 위한 다른 방식의 측정 방법 및 개선 방안이 필요하다.

<br>

### 5.5.1 사용자 경험 지표 바로 알기

- 웹 사이트 성능을 잘 관리하려면 어떤 지표를 사용할지가 중요하다.

- 최근에는 웹 사이트의 성능 지표가 브라우저 이벤트 중심 지표에서 사용자 중심 지표로 변화하고 있다.

- **사용자 중심의 지표에는 어떤 것이 있을까?**
  
  - WebPageTest의 Speed Index 지표가 사용되었다. Speed Index는 시간에 따른 웹 사이트의 시작 전 진행 상태를 수치화한 지표로, 값이 작을수록 시각적 진행 상태가 빠르다는 것을 의미한다.
  
  - 이 외에도 구글 크롬 팀을 주축으로 다양한 사용자 중심 성능 지표가 개발되고 있다.
    
    - 화면에 눈에 띄는 콘텐츠가 처음 표현되는 시점인 첫 번째 콘텐츠가 있는 페인트 (First Contentful Paint)
    
    - 히어로 이미지와 같은 주요 콘텐츠가 로딩되는 시점인 가장 큰 콘텐츠가 있는 페인트 (Largest Contentful Paint)
    
    - 사용자와 상호 작용이 어느 정도 가능해지는 시점인 상호 작용 시간 (Time to Interactive)
    
    - etc.

<br>

### 5.5.2 사용자 요청에 빠르게 반응하기

- 웹 사이트 방문자에게 첫 응답속도는 마치 사람의 첫인상처럼 중요하다.

- 사용자 요청에 빠르게 반응하려면 기본적으로 서버의 응답이 빨라야한다.
  
  - 브라우저가 서버에서 응답한 첫 번째 바이트를 수신하는 시간을 Time To First Byte라고 하는데 일반적으로 300~500ms가 이상적이라고 할 수 있다. 이를 위해서는 HTML 내의 주석이나 공백 등 불필요한 코드들을 모두 제거하여 전송되는 바이트 크기를 줄여야 한다. 또한 HTML 페이지를 캐시하여 서버 처리 시간을 최소화하는 것을 권한다.

- HTML이 브라우저에 일단 다운로드되면 렌더링에 필요한 리소스들을 빠르게 로딩시켜 1초 이내에 브라우저가 화면 렌더링을 시작해야 사용자가 지연을 느끼지 않는다.

- 브라우저가 렌더링을 빠르게 시작하게 하려면 아래와 같은 최적화 기법들이 있다.
  
  - CSS와 자바스크립트 파일들의 크기를 줄인다.
    
    - 크기를 줄이려면 공백과 주석을 제거하는 방법이 있다.
    
    - 근본적으로는 렌더링할 페이지에 필요한 부분만 남기고 필요하지 않은 부분은 제거하는 방법이 더 확실하다.
  
  - CSS와 자바스크립트들을 중요 리소스와 그렇지 않은 리소스로 분류한다.
    
    - 기본적으로, 화면 안쪽의 웹 콘텐츠를 렌더링하기 위한 파일들이 중요 리소스에 속한다.
  
  - 중요 리소스들은 가능한 빠르게 로딩시킨다.
  
  - 중요하지 않은 리소스들은 나중에 로딩 시킨다.

<br>

### 5.5.3 사용자 시선 붙잡기

- 브라우저가 화면 렌더링을 시작했더라도 2초 안에 의미 있는 콘텐츠가 표현되지 않으면 사용자가 사이트를 이탈할 가능성이 높아진다.

- 사용자가 이탈하지 않도록 시선을 붙잡으려면 Hero 이미지가 가능한 빠르게 화면에 로딩되어야한다.
  
  - Hero 이미지가 늦게 로딩이 된다면 그 이유는 페이지 로딩 시간을 개선하기 위해 모든 이미지들을 일괄적으로 지연 로딩 시켰기 때문일 것이다.
    
    - 지연 로딩이 적용된 이미지들은 브라우저의 프리로터 스레드 대상에 포함되지 않기 때문에 Hero 이미지 또한 렌더링이 늦게 된다.
    
    - 이를 방지 하기 위해서 Hero 이미지를 제외한 이미지들만 지연 로딩을 시켜주면 된다.
  
  - Hero 이미지가 늦게 로딩이 되는 또 다른 이유는 CSS의 background-image 속성으로 지정되었을 경우일 것이다.
    
    - HTML의 img 태그로 지정된 이미지들은 HTML 구문 분석과 함께 다운로드 되지만 CSS background-image 속성으로 지정된 이미지들은 CSS가 분석되고 DOM에 적용될 때 다운로드 되고 프리로더에도 적용되지 않는다. 그러므로 다른 이미지들보다 훨씬 늦게 다운로드된다.

- Hero 이미지를 빠르게 로딩하는 것과 더불어 이미지와 함께 메인 텍스트 역시 의미 있는 콘텐츠로 구성하면 좋을 것이다.
  
  - 일반적으로 브라우저에서 텍스트는 폰트를 먼저 다운로드해야 비로소 표현되므로 핵심 메시지를 사용자에게 빠르게 나타내려면 폰트를 빨리 다운로드해야 한다. 

<br>

### 5.5.4 사용자 상호 작용 방해하지 않기

- 브라우저가 페이지를 시각적으로 완성했다 하더라도 버튼 클릭, 스크롤 등의 상호 작용이 원활하지 않으면 사용자들의 불만이 증가하고 급기야 타 사이트로 이탈할 수 있다.
  
  - 따라서 사용자의 상호 작용을 측정하는 Time to Interactive나 First Input Delay 같은 지표가 웹 사이트 평판을 가늠하는 훌륭한 지표가 될 수 있다.
