# Chapter 05 웹에서 가속을 이끌어 내는 방법

## 5.1 웹 브라우저 현황 알아보기

<br>

- 데스크탑, 모바일을 막론하고 크롬의 점유율이 과반수
- 그럼에도 한국에서는 MS의 브라우저(IE, Edge)의 점유율이 꽤 높은 것이 사실이다.
- 이미지 형식, 폰트 등 점유율이 높은 브라우저에 맞게 준비할 필요가 있다.

<br>

## 5.2 웹 브라우저 동작 이해하기

<br>

- 사용자가 주소 입력창에 웹 사이트 주소를 입력했을 때, 브라우저의 동작은 다음과 같다.
  - 도메인 서버와 통신하여 호스트의 IP를 찾는다.
  - 해당 IP를 가진 서버와 TCP 연결을 맺는다.
  - HTTPS에서는 암호화된 연결을 생성하려는 협의 단계가 추가된다.
  - 연결이 맺어지면 서버로부터 필요한 리소스들을 다운로드한다.
  - 서버에서 가져온 리소스를 통해 화면을 구성한다.
- 브라우저의 리소스 다운로드 과정
  - 방문하는 페이지의 HTML 문서를 서버에 요청해 다운로드한다.
  - HTML 문서를 분석하면서 HTML 태그에 참조된 CSS, JS, 이미지, 폰트 등의 하위 리소스들을 차례로 다운로드한다.

<br>

### 5.2.1 브라우저 아키텍처

<br>

브라우저의 구성요소는 크게 7개의 컴포넌트로 나뉜다.

<br>

1. 유저 인터페이스
    - 사용자가 브라우저를 통해 상호 작용하도록 돕는다.
    - 주소 입력창, 북마크, 앞뒤 버튼 등이 이에 해당한다.
    - 브라우저별로 차별화된 기능을 제공하기도 한다.
2. 브라우저 엔진
    - 유저 인터페이스와 렌더링 엔진 사이에서 렌더링 상태를 조회하고 렌더링 작업을 제어하기 위한 인터페이스를 제공
3. 렌더링 엔진
    - HTML이나 CSS를 분석해 실제 웹컨텐츠를 브라우저 창에 그리는 역할
    - Webkit(사파리), Gecko(파이어폭스), Blink(크롬), Trident(IE) 등의 렌더링 엔진이 있다.
4. 네트워킹
    - HTTP 요청을 보내고 응답을 받는 역할
    - DNS 조회, TCP 연결 생성등을 수행
    - 브라우저 별로 6-10개 스레드로 동시에 네트워킹을 수행할 수 있다.
5. UI 백엔드
    - 콤보박스, 드롭박스 등 기본적인 UI 컴포넌트를 제공
6. 자바스크립트 해석기
    - V8, Spider Monkey 등의 엔진을 통해 자바스크립트를 분석하고 해석한다.
7. 데이터 저장소
    - 쿠키, 웹 스토리지, 인덱스 DB 등을 이용해 데이터를 저장

<br>

### 5.2.2 중요 렌더링 경로

<br>

- 렌더링 엔진이 화면을 그리는 작업은 선후 관계가 비교적 명확하므로 단일 스레드에 의해 수행된다.
- 브라우저의 중요 렌더링 경로는 다음과 같다.
    ![critical-rendering-path](https://user-images.githubusercontent.com/57767891/148157676-9c817cb4-97e6-48e9-8630-9633dab0eba1.png)

<br>

#### 1. DOM트리 생성
  - HTML의 태그를 하나하나 해석해 DOM이라는 객체 모델로 변환한다.
  - DOM은 객체지향 프로그래밍 언어들로 HTML이나 XML 형태의 마크업 문서를 조작하기 위해 규정한 인터페이스이다.
  - DOM은 객체의 속성과 메서드, 이벤트 등을 정의한다.
  - 브라우저의 분석기는 HTML문서를 위에서부터 순차적으로 분석해 부모노드와 자식노드의 관계를 파악해 DOM트리를 생성한다.

<br>

#### 2. CSSOM트리 생성
  - CSSOM은 DOM과 비슷하게 CSS를 처리하기 위한 트리 구조의 인터페이스이다.
  - HTML 문서를 분석하다 CSS를 참조하는 링크를 만나면 CSS리소스를 다운로드하고 이를 분석한다.
  - 이때 CSS분석은 다른 스레드에서 동작하기 때문에 HTML 분석 과정이 방해 받지는 않는다.

<br>

#### 3. 렌더트리 생성
  - DOM트리와 CSSOM트리를 병합해 렌더 트리를 생성한다.
  - 렌더링을 위한 최종 정보를 가진 렌더 객체들을 생성해 이들의 상하관계를 트리로 구성한다.
  - 하나의 렌더 객체는 하나의 박스모델을 나타낸다.
  - body 태그는 루트 노드로 대체 된다.
  - 렌더트리는 실제 화면에 그려질 노드들을 표현하기 때문에 `display:none` 스타일을 가지고 있는 노드는 제외 된다.

<br>

#### 4. 레이아웃
  - 레이아웃은 렌드 트리 노드들의 위치 정보가 계산되는 단계이다.
  - 각 렌더 객체에 해당하는 박스모델의 크기와 위치를 계산한다.
  - 이러한 계산은 루트노드부터 시작된다. 루트 노드의 너비는 뷰포트의 크기로 지정된다.
  - 너비는 부모 => 자식 순으로 높이는 자식 => 부모 순으로 계산한다.
    - 부모의 높이가 특정 값으로 지정되어 있고 자식의 높이가 비율인 경우는?

<br>

#### 5. 페인트
  - 페인트는 렌더 트리의 정보를 바탕으로 각 픽셀을 채우는 과정
  - 레이어 단위로 이루어진다.

<br>

#### 5. 컴포지트
  - 여러 레이어를 쌓임 맥락에 맞게 합치는 작업

<br>

## 5.3 브라우저 렌더링 최적화하기

### 5.3.1 DOM 최적화하기

<br>

- HTML 구문 오류
  - HTML 구문 분석 과정은 비교적 관대하다. 태그를 닫지 않거나 테이블을 중첩하는 등의 구문 오류가 있어도 대부분 화면을 정상적으로 표현한다.
  - 구문 오류에도 화면을 정상적으로 표현하기 위해 브라우저는 각 상황에 대한 예외 처리를 제공한다.
  - 즉, 오류가 많을수로 브라우저는 예외 처리를 위해 많은 메모리와 CPU 파워를 소모한다.
  - 따라서 HTML 구문 오류를 최소화하는 것이 웹 성능을 향상시키는 방법이 될 수 있다.

- 과도한 태그 중첩
  - HTML 문서 구조가 복잡하게 작성되어 있으면 자바스크립트를 통해 스타일을 변경할 때 각 태그의 레이아웃을 다시 계산하고 재구성하는 데 더 많은 리소스와 시간을 소모한다.
  - 일반적으로 중첩 태그가 15단계를 넘지 않도록 작성하는 것을 권장한다.

- DOM Monster
  - [DOM Monster](http://mir.aculo.us/dom-monster)를 통해 DOM 최적화를 위한 사항들을 확인 할 수 있다.

<br>

### 5.3.2 자바스크립트와 CSS 배치하기

<br>

- HTML을 해석하는 중 자바스크립트를 만나면 해당 스크립트를 다운로드하고 수행이 완료될 때까지 DOM 생성 작업을 중단한다.
  - 자바스크립트에 의한 DOM 변경이 완료될 때까지 기다린다.
- 자바스크립트에서 스타일 요소를 변경하려 할 경우 CSSOM 생성이 완료될 때까지 수행을 멈추고 기다린다.
- 따라서 CSS는 최대한 소스 위쪽에 배치해 CSSOM이 가능한 빨리 생성되도록 해야한다.
- 자바스크립트는 가능한 DOM과 CSSOM이 모두 생성된 이후 수행되도록 한다.

<br>

### 5.3.3 자바스크립트 최적화하기

<br>

- 자바스크립트는 렌더링 방해 요소 중 하나이다.
- 자바스크립트가 렌더링에 주는 영향을 막기위해 자바스크립트 별도의 스레드로 수행할 필요가 있다.
- script태그의 async 속성과 defer 속성으로 이를 해결할 수 있다.
- async
  - 별도의 스레드로 자바스크립트를 다운로드하고 실행한다.
  - 지연 수행 시 스크립트 간 선후 관계를 따지지 않는다.
- defer
  - 별도의 스레드로 자바스크립트를 다운로드하고 HTML 분석이 끝난 이후 실행한다.
  - 스크립트가 호출된 순서에 따라 차례로 수행된다.

<br>

### 5.3.4 CSS 최적화하기

<br>

- CSS는 렌더링 우선 순위가 가장 높으면서 렌더링을 가장 방해하는 요소이다.
- CSS의 내용은 점점 무거워 지지만 기기에 따라 화면으로 볼 수 있는 내용은 제한적이다.
- 숨겨져있는 부분이나 다른 기기를 위한 CSS까지 모두 한 파일로 받아오는 것은 렌더링을 지연시킨다.
- 필요한 CSS 정보만 빠르게 다운로드하고 실행해야 브라우저 렌더링을 가속시킬 수 있다.
  - 필요한 페이지에 필요한 CSS 파일만 포함해야한다.
  - 첫 화면에 사용될 CSS 파일과 숨겨진 화면에 사용될 CSS파일을 분리해 후자의 CSS는 지연 수행시켜야한다.
- 미디어 쿼리를 통해 조건에 맞는 CSS만 다운로드하도록 할 수 있다.
    ```html
    <link rel="stylesheet" media="screen and (max-device-width: 480px)" href="styles_base.css" />
    <link rel="stylesheet" media="screen and (min-device-width: 481px) and (max-device-width: 780px)" href="styles_mobile.css" />
    <link rel="stylesheet" media="screen and (min-device-width: 781px)" href="styles_desktop.css" />
    ```
- 숨겨진 화면에 적용될 CSS는 onLoad 이벤트 발생 이후 적용하도록 처리한다.
    ```html
    <--! critical css -->
    <link ref="stylesheet" media="all" href="..." />

    <--! non-critical css -->
    <link ref="stylesheet" defer-ref="..." />
    <link ref="stylesheet" defer-ref="..." />
    ```

    ```js
    const lazyLoadCSS = () => {
      const styles = document.querySelectorAll("link");

      styles.forEach(style => {
        const ref = style.getAttribute("defer-ref");

        if (ref) {
          style.href = ref;
        }
      });
    };
    
    window.addEventListener("load", lazyLoadCSS);
    ```

<br>

### 5.3.5 이미지 로딩 최적화하기

<br>

- img태그 사용시 `display: none`속성에 의해 실제 렌더 트리에 추가되지 않더라고 이미지는 다운로드 하게 된다.
  - DOM트리와 CSSOM트리는 따로 생성되기 때문에!
  - 이러한 이미지의 다운로드를 막을 수 있다면 렌더링을 더욱 가속화할수 있다.
- 이미지가 주요 이미지가 아니라면 background-image를 통해 처리할 수 있다.
  - CSS 분석시 display 속성을 알 수 있기 때문
- 자바스크립트를 통한 지연로딩을 할 수 있다.(4장)
  - 지연로딩의 경우 사용자 경험에는 도움이 되지 않을 수 있다.
  - preloading이 불가하기 때문
- Progressive JPG를 활용할 수 있다.
  - Progressive JPG는 초기에 저품질이미지를 다운 받고 점차 품질을 회복할 수 있게 분할 전송한다.

<br>

## 5.4 도메인 분할 기법 이용하기

<br>

- 하나의 TCP 연결에서는 리소스들을 순차적으로 다운로드 해야한다.
- 보통 브라우저는 동일 도메인 당 6~13개의 TCP 연결을 동시 생성할 수 있도록 허용한다.
- 여러 도메인을 사용해 더 많은 리소스를 병렬적으로 다운로드 받을 수 있다면 더욱 성능을 끌어올릴 수 있다.
- 예를 들어 www.beuccol.com라는 사이트에서 다음과 같이 추가 도메인을 디자인 할 수 있다.
  - img.beuccol.com
  - script.beuccol.com
  - api.beuccol.com
- 그러나 너무 많은 도메인은 오히려 성능을 해친다.
  - 동시 다운로드 수가 많을 수록 브라우저는 더 많은 CPU리소스를 사용하기 때문
  - 각 도메인에 대한 DNS 조회도 고려해야한다.
- 따라서 여러 상황을 고려해 도메인 수를 정해야한다.
- 도메인의 수가 정해지면 그 수에 맞게 리소스를 균등 분할해야한다.
  - 특정 도메인에서만 많은 리소스를 담당하면 다른 도메인들은 오히려 TCP연결을 위한 리소스만 낭비하는 꼴이 된다.
- 리소스의 성격에 따라 도메인을 나눌 수도 있지만 동적으로 도메인을 나눌 수도 있다.
  - 정확한 리소스 분배를 위해 리소스 성격보다는 배포 시점에 동적으로 도메인을 나누는 것이 권장된다.
  - 이때 특정 리소스가 항상 같은 도메인에 배정되어야 캐시 적중률이 높아진다.
  - 해시를 통해 특정 리소스를 같은 도메인에 배정할 수 있다.

<br>

### 5.4.1 도메인 분할 기법과 HTTP/2

<br>

- HTTP/2에서는 멀티플렉싱 기술로 인해 도메인 분할 기법을 사용할 이유가 사라졌다.
  - 오히려 이 기법이 HTTP/2의 헤더 압축 전송, 우선순위 전송, 서버푸시 기능 등을 방해한다고 한다.
- 최근 브라우저들은 HTTP/2의 기능을 저해하지 않으면서 다중 도메인을 사용할 수 있는 방법을 제공한다.
  - TCP 연결을 병합하는 방식
  - 브라우저가 첫 번째 도메인과 맺은 TCP 연결을 나머지 도메인에 재사용하는 방식
  - 이때 각 도메인이 동일한 IP 주소를 반환해야한다.
  - 그리고 동일한 인증서를 사용해야한다.

<br>

## 5.5 사용자 경험 개선하기

### 5.5.1 사용자 경험 지표 바로 알기

<br>

- 페이지 로딩 시점이 시각적으로 로딩을 완료한 시점은 아니다.
- 웹사이트의 성능 지표가 브라우저 이벤트(load) 중심 지표에서 사용자 중심 지표로 변화하고 있다.
- 사용자 중심 지표
  - WebPageTest의 Speed Index
    - 시간에 따른 웹사이트의 시각적 진행상태를 수치화한 지표
    - 값이 작을 수록 시각적 진행 상태가 빠르다는 것을 의미한다.
    - 페이지 로드 시점까지 시각적으로 완성되지 못한 부분의 면적을 계산한다.
  - FCP, LCP, TTI 등

<br>

### 5.5.2 사용자 요청에 빠르게 반응하기

<br>

- 사람은 응답속도가 100ms 늦어질 때 이를 인지하고 1초가 지나면 지연으로 인식한다.
- 즉, 사용자의 행동에 대해 적어도 1초 안에 반응해야 자연스럽게 그 다음 반응을 기대한다.
- TTFB의 경우 300~500ms가 이상적이다.
  - 이를 위해 HTML 문서의 크기를 최대한 줄이고 캐시될 수 있도록 해야한다.
- HTML이 다운로드되면 리소스들을 빠르게 로딩시켜 1초 이내 렌더링을 시작해야 사용자가 지연을 느끼지 않는다.
  - CSS, 자바스크립트의 크기를 줄인다.(minimize)
  - 개발자 도구 => Customize and control DevTools => More tools => Coverage 모듈을 통해 페이지에서 실제 사용되는 코드를 알 수 있다.
  - 이를 통해 코드를 분리하는 것을 권장한다.
  - HTTP/2에 경우 요청 수와 관계없이 전체 리소스 크기를 줄여야 다운로드 속도가 향상된다.
- critical resource와 non-critical resource를 구분하자.
  - 기본적으로 above the fold에 대한하는 컨텐츠를 렌더링하기 위한 파일들이 critical resource에 해당한다.
  - preload 사용
  - HTTP/2 서버 푸시 활용
    - 서버 푸시는 클라이언트가 요청하지 않은 리소스를 서버에서 제공해주는 방식을 의미한다.
    - 클라이언트가 HTML 문서를 요청한 경우 HTML에 포함되어 있는 리소스도 같이 보내줄 수 있다.
    - 최초 HTML이 다운로드 되는 시점에 이루어지기 때문에 preload보다 더 빠르게 critical resource를 다운받을 수 있다.
  - non-critical resource에 경우 defer나 async 속성을 통해 지연 로드한다.
    - CSS에 경우에도 JS를 사용해 지연 로딩한다.
<br>

### 5.5.3 사용자 시선 붙잡기

<br>

- 브라우저가 빠르게 화면 렌더링을 시작해도 2초 안에 의미 있는 컨텐츠가 표현되지 않으면 사용자가 사이트를 이탈할 가능성이 높다.
- 사용자가 이탈하지 않도록 시선을 붙잡으려면 Hero 이미지가 가능한 빠르게 화면에 로딩되어야 한다.
  - Hero 이미지를 지연로딩에 포함시키지 않아야한다.
  - Hero 이미지 사용시 preload속성을 사용한다.
  - Hero가 background-image로 지정되어 있으면 늦게 로딩 될 수 있다.
  - img 태그나 picture태그로 지정된 이미지는 HTML 분석 시 다운로드 되지만 CSS background에 경우 CSS 분석 후 DOM에 적용될 때 다운로드 되기 때문
  - background로 지정되어 있으면 프리로더에도 적용되지 않는다.
- 메인 텍스트에 사용되는 폰트 또한 prelaod를 적용한다.
  - 폰트에 경우 경량화된 서브셋 폰트를 사용해 크기를 줄일 수 있다.
- 폰트 로딩 방식에는 두가지가 있다.
  - 웹폰트를 완전히 다운로드한 후 텍스트를 나타내는 FOIT(Flash Of Invisible Text) 방식
  - 시스템 폰트를 먼저 사용 후 웹 폰트가 다운로드 되면 대체 하는 FOUT(Flash Of Unstyled Test) 방식
  - 크롬에서는 3초까지는 FOIT, 이후에는 FOUT방식을 사용한다.
  - FOUT을 강제하려면 font-face 룰에서 font-display 속성을 swap으로 바꾼다.

<br>

### 5.5.4 사용자 상호 작용 방해하지 않기

<br>

- 화면이 시각적으로 완성되어도 버튼 클릭, 스크롤 등 상호 작용이 원할하지 않으면 사용자들은 불편함을 느낀다.
- TTI나 FID(First Input Delay) 같은 지표를 사용해 이를 평가할 수 있다.
- TTI는 CPU 유휴 시간과 네트워크 사용량 등 클라이언트의 물리적 지표에 의해 결정된다.
- 따라서 다운로드하는 리소스의 양, 수행 스크립트를 줄이는 것이 중요하다.
